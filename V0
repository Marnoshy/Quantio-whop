//@version=5
indicator("Surferpips PRO BOX with MTF Status & Stats (Adjusted Prob V2 + Configurable Refined Entry - Simple Label)", overlay=true, max_lines_count = 500, max_labels_count = 10, max_boxes_count = 100) // Increased limits

// === Input Settings ===
lookback_length = input.int(10, title="Sensitivity level", minval=1)
refined_entry_percent = input.float(70.0, title="Refined Entry Level (% from SL)", minval=0.0, maxval=100.0, step=1.0)
x = 20 // For ACTIVE signal lines/labels
box_display = "Both Boxes" // Hardcoded
signal_label_size = input.string(size.normal, title="Signal Label Size", options=[size.tiny, size.small, size.normal, size.large, size.huge])
atr_len_input = 14
atr_offset_mult = 0.1
show_line_fill_active = true
persistent_line_width = 1

// === RSI Settings ===
rsi_length = 14
rsi_source = close
rsi_lower = 30
rsi_upper = 70
rsi_value = ta.rsi(rsi_source, rsi_length)
crossover_30 = ta.crossover(rsi_value, rsi_lower)
crossover_70 = ta.crossunder(rsi_value, rsi_upper)

// === Fractal Detection ===
up_fractal = ta.highest(high, 5) == high[2] and high[2] > high[1] and high[2] > high[3] and high[2] > high[0] and high[2] > high[4]
down_fractal = ta.lowest(low, 5) == low[2] and low[2] < low[1] and low[2] < low[3] and low[2] < low[0] and low[2] < low[4]
var float last_up_fractal_high = na
var int last_up_fractal_index = na
if up_fractal
    last_up_fractal_high := high[2]
    last_up_fractal_index := bar_index[2]
var float last_down_fractal_low = na
var int last_down_fractal_index = na
if down_fractal
    last_down_fractal_low := low[2]
    last_down_fractal_index := bar_index[2]

// === High/Low Logic ===
lowest_low = ta.lowest(low, lookback_length)
var int lowest_low_index = na
lowest_low_real_index = bar_index
for i = 0 to lookback_length - 1
    if low[i] == lowest_low
        lowest_low_index := i
        lowest_low_real_index := bar_index[i]
        break
highest_high = ta.highest(high, lookback_length)
var int highest_high_index = na
highest_high_real_index = bar_index
for i = 0 to lookback_length - 1
    if high[i] == highest_high
        highest_high_index := i
        highest_high_real_index := bar_index[i]
        break
var float updated_buy_fractal_level = na
if not na(lowest_low_real_index) and not na(last_up_fractal_index)
    if last_up_fractal_index < lowest_low_real_index
        updated_buy_fractal_level := last_up_fractal_high
var float updated_sell_fractal_level = na
if not na(highest_high_real_index) and not na(last_down_fractal_index)
    if last_down_fractal_index < highest_high_real_index
        updated_sell_fractal_level := last_down_fractal_low

// === RSI Cross Recency ===
recent_crossover_30 = false
recent_crossover_70 = false
for i = 0 to 19
    if crossover_30[i]
        recent_crossover_30 := true
        break
for i = 0 to 19
    if crossover_70[i]
        recent_crossover_70 := true
        break

// === Reset Signal Triggers ===
var bool buy_signal_triggered = false
var bool sell_signal_triggered = false
if crossover_30
    buy_signal_triggered := false
if crossover_70
    sell_signal_triggered := false

// === Confirmation Candle Logic ===
body_size = math.abs(close[1] - open[1])
candle_range = high[1] - low[1]
body_to_range_ratio = candle_range > 0 ? body_size / candle_range : 0
bull_confirm = not na(updated_buy_fractal_level) and close[1] > open[1] and close[1] > updated_buy_fractal_level and body_to_range_ratio > 0.5
bear_confirm = not na(updated_sell_fractal_level) and close[1] < open[1] and close[1] < updated_sell_fractal_level and body_to_range_ratio > 0.5

// === Final Signal Conditions ===
buy_signal_condition = not buy_signal_triggered[1] and recent_crossover_30[1] and
     not na(updated_buy_fractal_level[1]) and
     not na(lowest_low[1]) and
     not na(last_up_fractal_index[1]) and
     (updated_buy_fractal_level[1] - lowest_low[1]) > 0 and
     close[1] > updated_buy_fractal_level[1] and
     bull_confirm[0]

sell_signal_condition = not sell_signal_triggered[1] and recent_crossover_70[1] and
     not na(updated_sell_fractal_level[1]) and
     not na(highest_high[1]) and
     not na(last_down_fractal_index[1]) and
     (highest_high[1] - updated_sell_fractal_level[1]) > 0 and
     close[1] < updated_sell_fractal_level[1] and
     bear_confirm[0]


// === Trade Management & Drawing Variables ===
var bool is_buy_trade_active = false
var bool is_sell_trade_active = false

// --- Active Trade Parameters ---
var float active_buy_tp1 = na
var float active_buy_tp2 = na
var float active_buy_sl = na
var float active_buy_entry = na
var float active_buy_refined_entry = na // Refined entry level for buy
var int   active_buy_start_bar_idx = na
var int   active_buy_confirm_bar_idx = na
var float active_buy_wr_tp1 = na // Stores the *base* WR for this trade
var float active_buy_wr_tp2 = na // Stores the *base* WR for this trade

var float active_sell_tp1 = na
var float active_sell_tp2 = na
var float active_sell_sl = na
var float active_sell_entry = na
var float active_sell_refined_entry = na // Refined entry level for sell
var int   active_sell_start_bar_idx = na
var int   active_sell_confirm_bar_idx = na
var float active_sell_wr_tp1 = na // Stores the *base* WR for this trade
var float active_sell_wr_tp2 = na // Stores the *base* WR for this trade

// --- Arrays to store ACTIVE drawing IDs ---
var line[] buy_lines = array.new_line()
var label[] buy_labels = array.new_label()
var box[] buy_boxes = array.new_box()
var linefill[] buy_fills = array.new_linefill()
var line[] sell_lines = array.new_line()
var label[] sell_labels = array.new_label()
var box[] sell_boxes = array.new_box()
var linefill[] sell_fills = array.new_linefill()

// --- Helper function to delete ACTIVE drawings ---
f_delete_active_drawings(lines_array, labels_array, boxes_array, fills_array) =>
    for line_id in lines_array
        line.delete(line_id)
    for label_id in labels_array
        label.delete(label_id)
    for box_id in boxes_array
        box.delete(box_id)
    for fill_id in fills_array
        linefill.delete(fill_id)
    array.clear(lines_array)
    array.clear(labels_array)
    array.clear(boxes_array)
    array.clear(fills_array)

// === Win Rate Calculation Logic ===
var int buy_win_count_tp2 = 0
var int buy_loss_count = 0
var int buy_tp1_hit_count = 0
var int sell_win_count_tp2 = 0
var int sell_loss_count = 0
var int sell_tp1_hit_count = 0

var bool tp1_was_hit_this_trade = false // Tracks if TP1 hit *within* the currently active trade

// --- Calculate HISTORICAL Stats (Used for base probability before adjustment) ---
total_buy_trades = buy_win_count_tp2 + buy_loss_count
total_sell_trades = sell_win_count_tp2 + sell_loss_count
// Removed total_all_trades calculation
wr_tp1_buy = total_buy_trades > 0 ? (buy_tp1_hit_count / total_buy_trades) * 100 : 0.0
wr_tp1_sell = total_sell_trades > 0 ? (sell_tp1_hit_count / total_sell_trades) * 100 : 0.0
// Removed wr_tp1_total calculation
wr_tp2_buy = total_buy_trades > 0 ? (buy_win_count_tp2 / total_buy_trades) * 100 : 0.0
wr_tp2_sell = total_sell_trades > 0 ? (sell_win_count_tp2 / total_sell_trades) * 100 : 0.0
// Removed wr_tp2_total calculation
// R-Profit calculations REMOVED

// Helper function for formatting percentage
f_format_pct(value) => str.tostring(value, "#.##") + "%"

// === START: HTF Data Fetching ===

// Function to fetch basic active state and probabilities (lookahead_off)
f_get_active_trade_probs() =>
    is_buy = is_buy_trade_active[1]
    is_sell = is_sell_trade_active[1]
    b_tp1_p = is_buy ? nz(active_buy_wr_tp1[1], 0.0) : na
    b_tp2_p = is_buy ? nz(active_buy_wr_tp2[1], 0.0) : na
    s_tp1_p = is_sell ? nz(active_sell_wr_tp1[1], 0.0) : na
    s_tp2_p = is_sell ? nz(active_sell_wr_tp2[1], 0.0) : na
    [is_buy, is_sell, b_tp1_p, b_tp2_p, s_tp1_p, s_tp2_p]

// Function to fetch just the TP1 hit status (lookahead_on)
f_get_tp1_hit_status() =>
    [is_buy_trade_active[1] ? tp1_was_hit_this_trade[1] : false,
     is_sell_trade_active[1] ? tp1_was_hit_this_trade[1] : false]

// Fetch probabilities (lookahead=off)
[m1_is_buy, m1_is_sell, m1_b_tp1_p, m1_b_tp2_p, m1_s_tp1_p, m1_s_tp2_p] = request.security(syminfo.tickerid, "1", f_get_active_trade_probs(), lookahead=barmerge.lookahead_off)
[m5_is_buy, m5_is_sell, m5_b_tp1_p, m5_b_tp2_p, m5_s_tp1_p, m5_s_tp2_p] = request.security(syminfo.tickerid, "5", f_get_active_trade_probs(), lookahead=barmerge.lookahead_off)
[m15_is_buy, m15_is_sell, m15_b_tp1_p, m15_b_tp2_p, m15_s_tp1_p, m15_s_tp2_p] = request.security(syminfo.tickerid, "15", f_get_active_trade_probs(), lookahead=barmerge.lookahead_off)
[m30_is_buy, m30_is_sell, m30_b_tp1_p, m30_b_tp2_p, m30_s_tp1_p, m30_s_tp2_p] = request.security(syminfo.tickerid, "30", f_get_active_trade_probs(), lookahead=barmerge.lookahead_off)
[h1_is_buy, h1_is_sell, h1_b_tp1_p, h1_b_tp2_p, h1_s_tp1_p, h1_s_tp2_p] = request.security(syminfo.tickerid, "60", f_get_active_trade_probs(), lookahead=barmerge.lookahead_off)
[h4_is_buy, h4_is_sell, h4_b_tp1_p, h4_b_tp2_p, h4_s_tp1_p, h4_s_tp2_p] = request.security(syminfo.tickerid, "240", f_get_active_trade_probs(), lookahead=barmerge.lookahead_off)
[d1_is_buy, d1_is_sell, d1_b_tp1_p, d1_b_tp2_p, d1_s_tp1_p, d1_s_tp2_p] = request.security(syminfo.tickerid, "D", f_get_active_trade_probs(), lookahead=barmerge.lookahead_off)

// Fetch TP1 hit status (lookahead=on)
[m1_b_tp1_h, m1_s_tp1_h] = request.security(syminfo.tickerid, "1", f_get_tp1_hit_status(), lookahead=barmerge.lookahead_on)
[m5_b_tp1_h, m5_s_tp1_h] = request.security(syminfo.tickerid, "5", f_get_tp1_hit_status(), lookahead=barmerge.lookahead_on)
[m15_b_tp1_h, m15_s_tp1_h] = request.security(syminfo.tickerid, "15", f_get_tp1_hit_status(), lookahead=barmerge.lookahead_on)
[m30_b_tp1_h, m30_s_tp1_h] = request.security(syminfo.tickerid, "30", f_get_tp1_hit_status(), lookahead=barmerge.lookahead_on)
[h1_b_tp1_h, h1_s_tp1_h] = request.security(syminfo.tickerid, "60", f_get_tp1_hit_status(), lookahead=barmerge.lookahead_on)
[h4_b_tp1_h, h4_s_tp1_h] = request.security(syminfo.tickerid, "240", f_get_tp1_hit_status(), lookahead=barmerge.lookahead_on)
[d1_b_tp1_h, d1_s_tp1_h] = request.security(syminfo.tickerid, "D", f_get_tp1_hit_status(), lookahead=barmerge.lookahead_on)


// Structure to hold HTF data for easier iteration
type HtfData
    string tf_name
    bool is_buy
    bool is_sell
    float buy_tp1_prob
    float buy_tp2_prob
    bool buy_tp1_hit
    float sell_tp1_prob
    float sell_tp2_prob
    bool sell_tp1_hit

htf_data_array = array.new<HtfData>()
// Populate array (use nz() to handle potential 'na' from request.security)
array.push(htf_data_array, HtfData.new("M1", nz(m1_is_buy), nz(m1_is_sell), nz(m1_b_tp1_p), nz(m1_b_tp2_p), nz(m1_b_tp1_h), nz(m1_s_tp1_p), nz(m1_s_tp2_p), nz(m1_s_tp1_h)))
array.push(htf_data_array, HtfData.new("M5", nz(m5_is_buy), nz(m5_is_sell), nz(m5_b_tp1_p), nz(m5_b_tp2_p), nz(m5_b_tp1_h), nz(m5_s_tp1_p), nz(m5_s_tp2_p), nz(m5_s_tp1_h)))
array.push(htf_data_array, HtfData.new("M15", nz(m15_is_buy), nz(m15_is_sell), nz(m15_b_tp1_p), nz(m15_b_tp2_p), nz(m15_b_tp1_h), nz(m15_s_tp1_p), nz(m15_s_tp2_p), nz(m15_s_tp1_h)))
array.push(htf_data_array, HtfData.new("M30", nz(m30_is_buy), nz(m30_is_sell), nz(m30_b_tp1_p), nz(m30_b_tp2_p), nz(m30_b_tp1_h), nz(m30_s_tp1_p), nz(m30_s_tp2_p), nz(m30_s_tp1_h)))
array.push(htf_data_array, HtfData.new("H1", nz(h1_is_buy), nz(h1_is_sell), nz(h1_b_tp1_p), nz(h1_b_tp2_p), nz(h1_b_tp1_h), nz(h1_s_tp1_p), nz(h1_s_tp2_p), nz(h1_s_tp1_h)))
array.push(htf_data_array, HtfData.new("H4", nz(h4_is_buy), nz(h4_is_sell), nz(h4_b_tp1_p), nz(h4_b_tp2_p), nz(h4_b_tp1_h), nz(h4_s_tp1_p), nz(h4_s_tp2_p), nz(h4_s_tp1_h)))
array.push(htf_data_array, HtfData.new("D1", nz(d1_is_buy), nz(d1_is_sell), nz(d1_b_tp1_p), nz(d1_b_tp2_p), nz(d1_b_tp1_h), nz(d1_s_tp1_p), nz(d1_s_tp2_p), nz(d1_s_tp1_h)))

// === END: HTF Data Fetching ===


// === START: Probability Adjustment Function ===
f_adjust_probabilities(base_tp1_prob, base_tp2_prob, is_current_trade_buy) =>
    adj_tp1 = base_tp1_prob
    adj_tp2 = base_tp2_prob

    for i = 0 to array.size(htf_data_array) - 1
        htf = array.get(htf_data_array, i)

        htf_is_active = htf.is_buy or htf.is_sell
        if not htf_is_active
            continue

        htf_is_buy_trade = htf.is_buy
        htf_tp1_prob = htf_is_buy_trade ? htf.buy_tp1_prob : htf.sell_tp1_prob
        htf_tp2_prob = htf_is_buy_trade ? htf.buy_tp2_prob : htf.sell_tp2_prob
        htf_tp1_hit = htf_is_buy_trade ? htf.buy_tp1_hit : htf.sell_tp1_hit

        bool directions_match = (is_current_trade_buy and htf_is_buy_trade) or (not is_current_trade_buy and not htf_is_buy_trade)

        if directions_match // Rule (A) - SAME direction
            if not htf_tp1_hit
                if htf_tp1_prob > 50
                    adj_tp1 += 10.0
                    adj_tp2 += 10.0
                else
                    adj_tp1 -= 10.0
                    adj_tp2 -= 10.0
            else // TP1 is HIT on HTF
                if htf_tp2_prob > 50
                    adj_tp1 += 5.0
                    adj_tp2 += 5.0
                else
                    adj_tp1 -= 5.0
                    adj_tp2 -= 5.0
        else // Rule (B) - OPPOSITE direction
            if not htf_tp1_hit
                if htf_tp1_prob > 50
                    adj_tp1 -= 10.0
                    adj_tp2 -= 10.0
                else
                    adj_tp1 += 5.0
                    adj_tp2 += 5.0
            else // TP1 is HIT on HTF
                if htf_tp2_prob > 50
                    adj_tp1 -= 5.0
                    adj_tp2 -= 5.0
                else
                    adj_tp1 += 5.0
                    adj_tp2 += 5.0

    final_tp1 = math.max(0.0, math.min(100.0, adj_tp1))
    final_tp2 = math.max(0.0, math.min(100.0, adj_tp2))

    [final_tp1, final_tp2]

// === END: Probability Adjustment Function ===


// --- Trade Entry Logic ---
if buy_signal_condition and not is_buy_trade_active and not is_sell_trade_active
    f_delete_active_drawings(buy_lines, buy_labels, buy_boxes, buy_fills)
    if is_sell_trade_active
        f_delete_active_drawings(sell_lines, sell_labels, sell_boxes, sell_fills)
        is_sell_trade_active := false

    is_buy_trade_active := true
    tp1_was_hit_this_trade := false // Reset TP1 hit flag for the new trade

    current_lowest_low = lowest_low[1]
    current_updated_buy_fractal_level = updated_buy_fractal_level[1]
    current_box_distance = current_updated_buy_fractal_level - current_lowest_low
    active_buy_sl := current_lowest_low
    active_buy_entry := current_updated_buy_fractal_level
    active_buy_tp1 := active_buy_entry + current_box_distance
    active_buy_tp2 := active_buy_entry + 2 * current_box_distance
    active_buy_start_bar_idx := last_up_fractal_index[1]
    active_buy_confirm_bar_idx := bar_index
    buy_signal_triggered := true

    refined_entry_mult = refined_entry_percent / 100.0
    active_buy_refined_entry := active_buy_sl + (active_buy_entry - active_buy_sl) * refined_entry_mult

    active_buy_wr_tp1 := wr_tp1_buy
    active_buy_wr_tp2 := wr_tp2_buy

    [adjusted_buy_tp1_prob, adjusted_buy_tp2_prob] = f_adjust_probabilities(active_buy_wr_tp1, active_buy_wr_tp2, true)

    box_left_persistent = active_buy_start_bar_idx
    box_right_persistent = active_buy_confirm_bar_idx
    if box_display == "Both Boxes" or box_display == "Second Box Only"
        box.new(left=box_left_persistent, right=box_right_persistent, top=active_buy_entry, bottom=active_buy_sl, border_color=color.new(#00FFA3, 50), bgcolor=color.new(color.green, 92))

    line.new(box_left_persistent, active_buy_sl, box_right_persistent, active_buy_sl, color=color.new(#FF005C, 0), style=line.style_dashed, width=persistent_line_width)
    line.new(box_left_persistent, active_buy_entry, box_right_persistent, active_buy_entry, color=color.new(color.yellow, 50), style=line.style_dashed, width=persistent_line_width)
    line.new(box_left_persistent, active_buy_tp1, box_right_persistent, active_buy_tp1, color=color.new(#00FFA3, 0), style=line.style_dotted, width=persistent_line_width)
    line.new(box_left_persistent, active_buy_tp2, box_right_persistent, active_buy_tp2, color=color.new(#00FFA3, 0), style=line.style_dotted, width=persistent_line_width)
    line.new(box_left_persistent, active_buy_refined_entry, box_right_persistent, active_buy_refined_entry, color=color.new(color.yellow, 50), style=line.style_dashed, width=persistent_line_width)


    line_end_x_active = active_buy_confirm_bar_idx + x

    if box_display == "Both Boxes" or box_display == "Second Box Only"
        active_box = box.new(left=active_buy_start_bar_idx, right=active_buy_confirm_bar_idx, top=active_buy_entry, bottom=active_buy_sl, border_color=color.new(#00FFA3, 0), bgcolor=color.new(color.green, 85))
        array.push(buy_boxes, active_box)

    line_sl = line.new(active_buy_start_bar_idx, active_buy_sl, line_end_x_active, active_buy_sl, color=color.new(#FF005C, 0), style=line.style_dashed, width=1)
    line_entry = line.new(active_buy_start_bar_idx, active_buy_entry, line_end_x_active, active_buy_entry, color=color.new(color.yellow, 0), style=line.style_dashed, width=1)
    line_refined_entry = line.new(active_buy_start_bar_idx, active_buy_refined_entry, line_end_x_active, active_buy_refined_entry, color=color.new(color.yellow, 0), style=line.style_dashed, width=1)
    line_tp1 = line.new(active_buy_start_bar_idx, active_buy_tp1, line_end_x_active, active_buy_tp1, color=color.new(#00FFA3, 0), style=line.style_dotted, width=1)
    line_tp2 = line.new(active_buy_start_bar_idx, active_buy_tp2, line_end_x_active, active_buy_tp2, color=color.new(#00FFA3, 0), style=line.style_dotted, width=1)
    array.push(buy_lines, line_sl)
    array.push(buy_lines, line_entry)
    array.push(buy_lines, line_refined_entry)
    array.push(buy_lines, line_tp1)
    array.push(buy_lines, line_tp2)

    label_sl = label.new(line_end_x_active, active_buy_sl, "✖ Stop loss: " + str.tostring(active_buy_sl, format.mintick), xloc = xloc.bar_index, yloc = yloc.price, color = color.new(#FF005C, 0), textcolor = color.white, style = label.style_label_left, textalign = text.align_left, size = size.normal)
    label_entry = label.new(line_end_x_active, active_buy_entry, "◉ Entry : " + str.tostring(active_buy_entry, format.mintick), xloc = xloc.bar_index, yloc = yloc.price, color = color.new(color.yellow, 0), textcolor = color.new(#020818, 0), style = label.style_label_left, textalign = text.align_left, size = size.normal)
    label_refined_entry = label.new(line_end_x_active, active_buy_refined_entry, "◉ Refined entry: " + str.tostring(active_buy_refined_entry, format.mintick), xloc = xloc.bar_index, yloc = yloc.price, color = color.new(color.yellow, 0), textcolor = color.new(#020818, 0), style = label.style_label_left, textalign = text.align_left, size = size.normal)
    label_tp1 = label.new(line_end_x_active, active_buy_tp1, "✔ TP 1 : " + str.tostring(active_buy_tp1, format.mintick) + " (" + f_format_pct(adjusted_buy_tp1_prob) + ")", xloc = xloc.bar_index, yloc = yloc.price, color = color.new(#00FFA3, 0), textcolor = color.new(#020818, 0), style = label.style_label_left, textalign = text.align_left, size = size.normal)
    label_tp2 = label.new(line_end_x_active, active_buy_tp2, "✔ TP 2 : " + str.tostring(active_buy_tp2, format.mintick) + " (" + f_format_pct(adjusted_buy_tp2_prob) + ")", xloc = xloc.bar_index, yloc = yloc.price, color = color.new(#00FFA3, 0), textcolor = color.new(#020818, 0), style = label.style_label_left, textalign = text.align_left, size = size.normal)
    array.push(buy_labels, label_sl)
    array.push(buy_labels, label_entry)
    array.push(buy_labels, label_refined_entry)
    array.push(buy_labels, label_tp1)
    array.push(buy_labels, label_tp2)

    if show_line_fill_active
        fill_sl_entry = linefill.new(line_sl, line_entry, color=color.new(color.red, 90))
        fill_entry_tp2 = linefill.new(line_entry, line_tp2, color=color.new(color.green, 90))
        array.push(buy_fills, fill_sl_entry)
        array.push(buy_fills, fill_entry_tp2)


if sell_signal_condition and not is_sell_trade_active and not is_buy_trade_active
    f_delete_active_drawings(sell_lines, sell_labels, sell_boxes, sell_fills)
    if is_buy_trade_active
        f_delete_active_drawings(buy_lines, buy_labels, buy_boxes, buy_fills)
        is_buy_trade_active := false

    is_sell_trade_active := true
    tp1_was_hit_this_trade := false // Reset TP1 hit flag for the new trade

    current_highest_high = highest_high[1]
    current_updated_sell_fractal_level = updated_sell_fractal_level[1]
    current_box_distance = current_highest_high - current_updated_sell_fractal_level
    active_sell_sl := current_highest_high
    active_sell_entry := current_updated_sell_fractal_level
    active_sell_tp1 := active_sell_entry - current_box_distance
    active_sell_tp2 := active_sell_entry - 2 * current_box_distance
    active_sell_start_bar_idx := last_down_fractal_index[1]
    active_sell_confirm_bar_idx := bar_index
    sell_signal_triggered := true

    refined_entry_mult = refined_entry_percent / 100.0
    active_sell_refined_entry := active_sell_sl - (active_sell_sl - active_sell_entry) * refined_entry_mult

    active_sell_wr_tp1 := wr_tp1_sell
    active_sell_wr_tp2 := wr_tp2_sell

    [adjusted_sell_tp1_prob, adjusted_sell_tp2_prob] = f_adjust_probabilities(active_sell_wr_tp1, active_sell_wr_tp2, false)

    box_left_persistent = active_sell_start_bar_idx
    box_right_persistent = active_sell_confirm_bar_idx
    if box_display == "Both Boxes" or box_display == "Second Box Only"
        box.new(left=box_left_persistent, right=box_right_persistent, top=active_sell_sl, bottom=active_sell_entry, border_color=color.new(#FF005C, 50), bgcolor=color.new(color.red, 92))

    line.new(box_left_persistent, active_sell_sl, box_right_persistent, active_sell_sl, color=color.new(#FF005C, 0), style=line.style_dashed, width=persistent_line_width)
    line.new(box_left_persistent, active_sell_entry, box_right_persistent, active_sell_entry, color=color.new(color.yellow, 50), style=line.style_dashed, width=persistent_line_width)
    line.new(box_left_persistent, active_sell_tp1, box_right_persistent, active_sell_tp1, color=color.new(#00FFA3, 0), style=line.style_dotted, width=persistent_line_width)
    line.new(box_left_persistent, active_sell_tp2, box_right_persistent, active_sell_tp2, color=color.new(#00FFA3, 0), style=line.style_dotted, width=persistent_line_width)
    line.new(box_left_persistent, active_sell_refined_entry, box_right_persistent, active_sell_refined_entry, color=color.new(color.yellow, 50), style=line.style_dashed, width=persistent_line_width)

    line_end_x_active = active_sell_confirm_bar_idx + x

    if box_display == "Both Boxes" or box_display == "Second Box Only"
        active_box = box.new(left=active_sell_start_bar_idx, right=active_sell_confirm_bar_idx, top=active_sell_sl, bottom=active_sell_entry, border_color=color.new(#FF005C, 0), bgcolor=color.new(color.red, 85))
        array.push(sell_boxes, active_box)

    line_sl = line.new(active_sell_start_bar_idx, active_sell_sl, line_end_x_active, active_sell_sl, color=color.new(#FF005C, 0), style=line.style_dashed, width=1)
    line_entry = line.new(active_sell_start_bar_idx, active_sell_entry, line_end_x_active, active_sell_entry, color=color.new(color.yellow, 0), style=line.style_dashed, width=1)
    line_refined_entry = line.new(active_sell_start_bar_idx, active_sell_refined_entry, line_end_x_active, active_sell_refined_entry, color=color.new(color.yellow, 0), style=line.style_dashed, width=1)
    line_tp1 = line.new(active_sell_start_bar_idx, active_sell_tp1, line_end_x_active, active_sell_tp1, color=color.new(#00FFA3, 0), style=line.style_dotted, width=1)
    line_tp2 = line.new(active_sell_start_bar_idx, active_sell_tp2, line_end_x_active, active_sell_tp2, color=color.new(#00FFA3, 0), style=line.style_dotted, width=1)
    array.push(sell_lines, line_sl)
    array.push(sell_lines, line_entry)
    array.push(sell_lines, line_refined_entry)
    array.push(sell_lines, line_tp1)
    array.push(sell_lines, line_tp2)

    label_sl = label.new(line_end_x_active, active_sell_sl, "✖ Stop loss: " + str.tostring(active_sell_sl, format.mintick), xloc = xloc.bar_index, yloc = yloc.price, color = color.new(#FF005C, 0), textcolor = color.white, style = label.style_label_left, textalign = text.align_left, size = size.normal)
    label_entry = label.new(line_end_x_active, active_sell_entry, "◉ Entry : " + str.tostring(active_sell_entry, format.mintick), xloc = xloc.bar_index, yloc = yloc.price, color = color.new(color.yellow, 0), textcolor = color.new(#020818, 0), style = label.style_label_left, textalign = text.align_left, size = size.normal)
    label_refined_entry = label.new(line_end_x_active, active_sell_refined_entry, "◉ Refined entry: " + str.tostring(active_sell_refined_entry, format.mintick), xloc = xloc.bar_index, yloc = yloc.price, color = color.new(color.yellow, 0), textcolor = color.new(#020818, 0), style = label.style_label_left, textalign = text.align_left, size = size.normal)
    label_tp1 = label.new(line_end_x_active, active_sell_tp1, "✔ TP 1 : " + str.tostring(active_sell_tp1, format.mintick) + " (" + f_format_pct(adjusted_sell_tp1_prob) + ")", xloc = xloc.bar_index, yloc = yloc.price, color = color.new(#00FFA3, 0), textcolor = color.new(#020818, 0), style = label.style_label_left, textalign = text.align_left, size = size.normal)
    label_tp2 = label.new(line_end_x_active, active_sell_tp2, "✔ TP 2 : " + str.tostring(active_sell_tp2, format.mintick) + " (" + f_format_pct(adjusted_sell_tp2_prob) + ")", xloc = xloc.bar_index, yloc = yloc.price, color = color.new(#00FFA3, 0), textcolor = color.new(#020818, 0), style = label.style_label_left, textalign = text.align_left, size = size.normal)
    array.push(sell_labels, label_sl)
    array.push(sell_labels, label_entry)
    array.push(sell_labels, label_refined_entry)
    array.push(sell_labels, label_tp1)
    array.push(sell_labels, label_tp2)

    if show_line_fill_active
        fill_sl_entry = linefill.new(line_sl, line_entry, color=color.new(#FF005C,90))
        fill_entry_tp2 = linefill.new(line_entry, line_tp2, color=color.new(#00FFA3, 90))
        array.push(sell_fills, fill_sl_entry)
        array.push(sell_fills, fill_entry_tp2)


// --- Active Trade Management & ACTIVE Drawing Updates ---
// Using high/low for hit detection remains correct for checking if the level was *touched*
if is_buy_trade_active
    current_line_end_x = bar_index + x
    if array.size(buy_lines) > 0
        for i = 0 to array.size(buy_lines) - 1
            line.set_x2(array.get(buy_lines, i), current_line_end_x)
    if array.size(buy_labels) > 0
        for i = 0 to array.size(buy_labels) - 1
            label.set_x(array.get(buy_labels, i), current_line_end_x)

    // Check TP1 Hit FIRST (only once per trade) - based on high touching TP1
    if not tp1_was_hit_this_trade and not na(active_buy_tp1) and high >= active_buy_tp1
        buy_tp1_hit_count += 1
        tp1_was_hit_this_trade := true // Set the flag when TP1 is hit

    // Check TP2 Hit - based on high touching TP2
    if not na(active_buy_tp2) and high >= active_buy_tp2
        if not (low <= active_buy_sl) // Check if SL wasn't also hit on the same bar
            buy_win_count_tp2 += 1
        else
            buy_loss_count +=1 // If SL hit same time or before TP2, count as loss
        is_buy_trade_active := false
        f_delete_active_drawings(buy_lines, buy_labels, buy_boxes, buy_fills)

    // Check SL Hit (only if TP2 was not hit on this bar) - based on low touching SL
    else if not na(active_buy_sl) and low <= active_buy_sl
        buy_loss_count += 1
        is_buy_trade_active := false
        f_delete_active_drawings(buy_lines, buy_labels, buy_boxes, buy_fills)


if is_sell_trade_active
    current_line_end_x = bar_index + x
    if array.size(sell_lines) > 0
        for i = 0 to array.size(sell_lines) - 1
            line.set_x2(array.get(sell_lines, i), current_line_end_x)
    if array.size(sell_labels) > 0
        for i = 0 to array.size(sell_labels) - 1
            label.set_x(array.get(sell_labels, i), current_line_end_x)

    // Check TP1 Hit FIRST (only once per trade) - based on low touching TP1
    if not tp1_was_hit_this_trade and not na(active_sell_tp1) and low <= active_sell_tp1
        sell_tp1_hit_count += 1
        tp1_was_hit_this_trade := true // Set the flag when TP1 is hit

    // Check TP2 Hit - based on low touching TP2
    if not na(active_sell_tp2) and low <= active_sell_tp2
        if not (high >= active_sell_sl) // Check if SL wasn't also hit on the same bar
            sell_win_count_tp2 += 1
        else
            sell_loss_count += 1 // If SL hit same time or before TP2, count as loss
        is_sell_trade_active := false
        f_delete_active_drawings(sell_lines, sell_labels, sell_boxes, sell_fills)

    // Check SL Hit (only if TP2 was not hit on this bar) - based on high touching SL
    else if not na(active_sell_sl) and high >= active_sell_sl
        sell_loss_count += 1
        is_sell_trade_active := false
        f_delete_active_drawings(sell_lines, sell_labels, sell_boxes, sell_fills)

// === END OF CORE TRADE LOGIC & DRAWING MANAGEMENT ===


// === Multi-Timeframe (MTF) Status Logic ===
// Fetch active status *from previous bar* for the dashboard using lookahead_off for responsiveness
m1_buy_active_dash = nz(request.security(syminfo.tickerid, "1", is_buy_trade_active[1], lookahead = barmerge.lookahead_off), false)
m1_sell_active_dash = nz(request.security(syminfo.tickerid, "1", is_sell_trade_active[1], lookahead = barmerge.lookahead_off), false)
m5_buy_active_dash = nz(request.security(syminfo.tickerid, "5", is_buy_trade_active[1], lookahead = barmerge.lookahead_off), false)
m5_sell_active_dash = nz(request.security(syminfo.tickerid, "5", is_sell_trade_active[1], lookahead = barmerge.lookahead_off), false)
m15_buy_active_dash = nz(request.security(syminfo.tickerid, "15", is_buy_trade_active[1], lookahead = barmerge.lookahead_off), false)
m15_sell_active_dash = nz(request.security(syminfo.tickerid, "15", is_sell_trade_active[1], lookahead = barmerge.lookahead_off), false)
m30_buy_active_dash = nz(request.security(syminfo.tickerid, "30", is_buy_trade_active[1], lookahead = barmerge.lookahead_off), false)
m30_sell_active_dash = nz(request.security(syminfo.tickerid, "30", is_sell_trade_active[1], lookahead = barmerge.lookahead_off), false)
h1_buy_active_dash = nz(request.security(syminfo.tickerid, "60", is_buy_trade_active[1], lookahead = barmerge.lookahead_off), false)
h1_sell_active_dash = nz(request.security(syminfo.tickerid, "60", is_sell_trade_active[1], lookahead = barmerge.lookahead_off), false)
h4_buy_active_dash = nz(request.security(syminfo.tickerid, "240", is_buy_trade_active[1], lookahead = barmerge.lookahead_off), false)
h4_sell_active_dash = nz(request.security(syminfo.tickerid, "240", is_sell_trade_active[1], lookahead = barmerge.lookahead_off), false)
d1_buy_active_dash = nz(request.security(syminfo.tickerid, "D", is_buy_trade_active[1], lookahead = barmerge.lookahead_off), false)
d1_sell_active_dash = nz(request.security(syminfo.tickerid, "D", is_sell_trade_active[1], lookahead = barmerge.lookahead_off), false)

// === START: MTF Status Dashboard (Single Line) ===
var table mtf_dashboard = table.new(position.top_right, 7, 1, border_width = 1, border_color=color.gray)
color mtf_buy_color = color.new(#00FFA3, 0)
color mtf_sell_color = color.new(#FF005C, 0)
color mtf_neutral_bg = color.white
color mtf_text_color = color.black

if barstate.islast
    // M1
    m1_bgcolor = m1_buy_active_dash ? mtf_buy_color : m1_sell_active_dash ? mtf_sell_color : mtf_neutral_bg
    table.cell(mtf_dashboard, 0, 0, "M1", bgcolor = m1_bgcolor, text_color = mtf_text_color, text_halign = text.align_center)
    // M5
    m5_bgcolor = m5_buy_active_dash ? mtf_buy_color : m5_sell_active_dash ? mtf_sell_color : mtf_neutral_bg
    table.cell(mtf_dashboard, 1, 0, "M5", bgcolor = m5_bgcolor, text_color = mtf_text_color, text_halign = text.align_center)
    // M15
    m15_bgcolor = m15_buy_active_dash ? mtf_buy_color : m15_sell_active_dash ? mtf_sell_color : mtf_neutral_bg
    table.cell(mtf_dashboard, 2, 0, "M15", bgcolor = m15_bgcolor, text_color = mtf_text_color, text_halign = text.align_center)
    // M30
    m30_bgcolor = m30_buy_active_dash ? mtf_buy_color : m30_sell_active_dash ? mtf_sell_color : mtf_neutral_bg
    table.cell(mtf_dashboard, 3, 0, "M30", bgcolor = m30_bgcolor, text_color = mtf_text_color, text_halign = text.align_center)
    // H1
    h1_bgcolor = h1_buy_active_dash ? mtf_buy_color : h1_sell_active_dash ? mtf_sell_color : mtf_neutral_bg
    table.cell(mtf_dashboard, 4, 0, "H1", bgcolor = h1_bgcolor, text_color = mtf_text_color, text_halign = text.align_center)
    // H4
    h4_bgcolor = h4_buy_active_dash ? mtf_buy_color : h4_sell_active_dash ? mtf_sell_color : mtf_neutral_bg
    table.cell(mtf_dashboard, 5, 0, "H4", bgcolor = h4_bgcolor, text_color = mtf_text_color, text_halign = text.align_center)
    // D1
    d1_bgcolor = d1_buy_active_dash ? mtf_buy_color : d1_sell_active_dash ? mtf_sell_color : mtf_neutral_bg
    table.cell(mtf_dashboard, 6, 0, "D1", bgcolor = d1_bgcolor, text_color = mtf_text_color, text_halign = text.align_center)
// === END: MTF Status Dashboard ===

// === STATS DASHBOARD SECTION ===
// Adjusted table size: 3 columns (Header, BUY, SELL), 3 rows (Header + 2 data rows for Win Rates)
var table results_table = table.new(position.bottom_right, 3, 3, border_width = 1, border_color = color.new(color.white, 80))
buy_bg = color.new(color.white, 0)
sell_bg = color.new(color.white, 0)
color row_header_bg = color.new(#000000, 30)
color high_wr_bg = color.new(#00FFA3, 0) // Define the high win rate background color

if barstate.islast
    // Use local variables for final calculation for the table
    local_total_buy_trades = buy_win_count_tp2 + buy_loss_count
    local_total_sell_trades = sell_win_count_tp2 + sell_loss_count
    // Removed local_total_all_trades

    wr_tp1_buy_final = local_total_buy_trades > 0 ? (buy_tp1_hit_count / local_total_buy_trades) * 100 : 0.0
    wr_tp1_sell_final = local_total_sell_trades > 0 ? (sell_tp1_hit_count / local_total_sell_trades) * 100 : 0.0
    // Removed wr_tp1_total_final
    wr_tp2_buy_final = local_total_buy_trades > 0 ? (buy_win_count_tp2 / local_total_buy_trades) * 100 : 0.0
    // ***** CORRECTION HERE *****
    wr_tp2_sell_final = local_total_sell_trades > 0 ? (sell_win_count_tp2 / local_total_sell_trades) * 100 : 0.0 
    // ***** CORRECTION ABOVE *****
    // Removed wr_tp2_total_final
    // R-Profit final calculations REMOVED

    // --- Determine Background Colors based on Win Rate ---
    buy_tp1_wr_bg = wr_tp1_buy_final > 70.0 ? high_wr_bg : buy_bg
    sell_tp1_wr_bg = wr_tp1_sell_final > 70.0 ? high_wr_bg : sell_bg
    buy_tp2_wr_bg = wr_tp2_buy_final > 70.0 ? high_wr_bg : buy_bg
    sell_tp2_wr_bg = wr_tp2_sell_final > 70.0 ? high_wr_bg : sell_bg

    // --- Populate Table (adjusted column and row indices) ---
    // Row 0: Headers
    table.cell(results_table, 1, 0, "BUY ⬆️", bgcolor = buy_bg, text_color = color.black, text_halign = text.align_center)
    table.cell(results_table, 2, 0, "SELL ⬇️", bgcolor = sell_bg, text_color = color.black, text_halign = text.align_center)
    // Removed TOTAL header cell
    // Removed Trades row (index 1)

    // Row 1: Win Rate TP1 (shifted up from index 2)
    table.cell(results_table, 0, 1, "Probability to reach TP1:", bgcolor = row_header_bg, text_color = color.white, text_halign = text.align_left)
    table.cell(results_table, 1, 1, f_format_pct(wr_tp1_buy_final), bgcolor = buy_tp1_wr_bg, text_color = color.black, text_halign = text.align_center) // Conditional BG
    table.cell(results_table, 2, 1, f_format_pct(wr_tp1_sell_final), bgcolor = sell_tp1_wr_bg, text_color = color.black, text_halign = text.align_center) // Conditional BG
    // Removed TOTAL WR TP1 cell

    // Row 2: Win Rate TP2 (shifted up from index 3)
    table.cell(results_table, 0, 2, "Probability to reach TP2:", bgcolor = row_header_bg, text_color = color.white, text_halign = text.align_left)
    table.cell(results_table, 1, 2, f_format_pct(wr_tp2_buy_final), bgcolor = buy_tp2_wr_bg, text_color = color.black, text_halign = text.align_center) // Conditional BG
    table.cell(results_table, 2, 2, f_format_pct(wr_tp2_sell_final), bgcolor = sell_tp2_wr_bg, text_color = color.black, text_halign = text.align_center) // Conditional BG
    // Removed TOTAL WR TP2 cell

// === END OF STATS DASHBOARD SECTION ===


// === ATR for Offset ===
atr_value = ta.atr(atr_len_input)
vertical_offset_atr = atr_value * atr_offset_mult

// === Plot Signal Labels (Appear only on signal bar) ===
if buy_signal_condition and not is_buy_trade_active[1] and not is_sell_trade_active[1]
    label.new(x=bar_index[1], y=low[1] - vertical_offset_atr,
              text="BUY", style=label.style_label_up,
              color=color.new(#00FFA3, 0), textcolor=color.black,
              size=signal_label_size, yloc=yloc.price, textalign = text.align_center)

if sell_signal_condition and not is_buy_trade_active[1] and not is_sell_trade_active[1]
    label.new(x=bar_index[1], y=high[1] + vertical_offset_atr,
              text="SELL", style=label.style_label_down,
              color=color.new(#FF005C,0), textcolor=color.white,
              size=signal_label_size, yloc=yloc.price, textalign = text.align_center)

// === Candle Coloring Logic (CORRECTED: Using 'close') ===
var color candle_color = na
candle_color := na // Reset color decision each bar

// Determine candle color based on active trade and CLOSE price relative to TP levels
if is_buy_trade_active
    // Buy trade active: Check if CLOSE price is above or below TP1
    if not na(active_buy_tp1) and close >= active_buy_tp1 // Candle CLOSED at or above TP1
        candle_color := color.new(#00D2FF, 0) // Cyan color (Between TP1 and TP2 or above TP2)
    else // Candle CLOSED below TP1
        candle_color := color.new(#00FFA3, 0) // Original buy signal color (< TP1)

else if is_sell_trade_active
    // Sell trade active: Check CLOSE price position relative to TP1 and TP2
    if not na(active_sell_tp1) and close <= active_sell_tp1 // Candle CLOSED at or below TP1
        // Check if it's strictly between TP1 and TP2
        if not na(active_sell_tp2) and close > active_sell_tp2 // Candle CLOSED below TP1 but above TP2
            candle_color := color.new(#FF005C, 0) // Second sell color (Between TP1 and TP2)
        else // Candle CLOSED at or below TP2 (or TP2 is na)
             // Based on user rule, this case doesn't get #FF005C.
             // Should it be #FF3C38 (initial sell color) or #FF005C (since TP1 was breached)?
             // Let's make it #FF005C, assuming the color change persists once TP1 is breached downwards.
             // If you strictly want #FF005C *only* between TP1 and TP2, change this line.
            candle_color := color.new(#FF005C, 0)
    else // Candle CLOSED above TP1
        candle_color := color.new(#FF3C38, 0) // Original sell signal color (> TP1)


// Plot candles using the determined color or default colors if no trade active
plotcandle(open, high, low, close, title="Price Candles",
     color = candle_color == na ? (close >= open ? color.new(color.green,15) : color.new(color.red,15)) : candle_color,
     wickcolor = candle_color == na ? color.new(color.gray, 30) : candle_color, // Use determined color for wick if active trade
     bordercolor = candle_color == na ? (close >= open ? color.new(color.green,15) : color.new(color.red,15)) : candle_color // Use determined color for border if active trade
     )
